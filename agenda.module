<?php
// $Id$

/**
 * Implementation of hook_help()
 */
function agenda_help($path, $arg) {
  $output = '';  //declare your output variable
  switch ($path) {
    case "admin/help#agenda":
      $output = '<p>'.  t("Displays an agenda of events from a google calendar") .'</p>';
      break;
    case "admin/settings/agenda/debug":
      $output = '<p>'.  t("The agenda block will not show when there are no applicable events to display. If the block is not showing, and you think it should, this page may help you debug the situation.") .'</p>';
      break;
  }
  return $output;
}

/**
 * Implementation of hook_perm()
 */
function agenda_perm() {
  return array('access agenda content');
}


/**
 * Implementation of hook_block()
 */
function agenda_block($op='list', $delta=0) {
  switch($op) {
    case 'list':
      $blocks[0] = array(
        'info'  => t("Agenda"),
        'cache' => BLOCK_CACHE_GLOBAL,
        );
      return $blocks;
      break;
      
    case 'view':
      $basepath = drupal_get_path('module', 'agenda');
      drupal_add_css($basepath . '/css/agenda-block.css');
      drupal_add_js($basepath . '/js/agenda.js');
      drupal_add_js($basepath . '/js/jquery.corners.js');
      $block = array(
        'subject' => t('Upcoming'),
        'content' => agenda_display_block(),
      );
      return $block;
      break;
  }
}


/**
 * Implementation of hook_theme()
 */
function agenda_theme($existing, $type, $theme, $path) {
  $theme = array(
    'agenda_block' => array(
      'arguments' => array('events' => array()),
      'template' => 'theme/agenda-block',
    ),
    'agenda_debug' => array(
      'arguments' => array('form' => '', 'output' => array()),
      'template' => 'theme/agenda-debug',
    ),
  );
  
  return $theme;
}


/**
 * Implementation of hook_menu()
 */
function agenda_menu() {

  $items = array();

  $items['admin/settings/agenda'] = array(
    'title' => 'Agenda',
    'description' => 'Configure rendering options and specify calendar sources',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('agenda_admin'),
    'access arguments' => array('access administration pages'),
   );

  $items['admin/settings/agenda/configure'] = array(
    'title'            => 'Configure',
    'description'      => 'Configure rendering options and specify calendar sources',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('agenda_admin'),
    'access arguments' => array('access administration pages'),
    'type'             => MENU_DEFAULT_LOCAL_TASK,
   );

  $items['admin/settings/agenda/debug'] = array(
    'title'            => 'Test Settings',
    'description'      => 'Show parsing steps when events are not showing',
    'page callback'    => 'agenda_debug',
    'access arguments' => array('access administration pages'),
    'type'             => MENU_LOCAL_TASK,
   );
      
  return $items;
}


/**
 * Admin configuration page
 */
function agenda_admin() {

  $form['agenda_old'] = array(
    '#type' => 'textfield',
    '#title' => t('Define old'),
    '#default_value' => variable_get('agenda_old', 'yesterday'),
    '#description' => t("A string indicating what old really is - events before this are not shown."),
    '#required' => TRUE,
  );
  
  $form['agenda_datelimit'] = array(
    '#type' => 'textfield',
    '#title' => t('Dates to display'),
    '#default_value' => variable_get('agenda_datelimit', 4),
    '#description' => t("The maximum number of unique dates to display."),
    '#required' => TRUE,
  );
  
  $form['agenda_cachetime'] = array(
    '#type' => 'textfield',
    '#title' => t('Amount of time to cache event data'),
    '#default_value' => variable_get('agenda_cachetime', 3600),
    '#description' => t("How long (in seconds) the module should hold onto the ICS data before re-requesting it from Google."),
    '#required' => TRUE,
  );
  
  $form['agenda_calendars'] = array(
    '#type' => 'textarea',
    '#title' => t('Google Calendar IDs'),
    '#default_value' => variable_get('agenda_calendars', ''),
    '#rows' => 4,
    '#description' => t("The public IDs of each google calendar you want to display, each on a newline."),
    '#required' => TRUE,
  );

  return system_settings_form($form);
}


/**
 * Implementation of hook_admin_validates
 */
function agenda_admin_validate($form, &$form_state) {
  // calendars (has the form of a valid email address)
  $calendars = $form_state['values']['agenda_calendars'];
  $ids = preg_split('@\r\n?|\n@', $calendars);
  if (empty($ids)) {
    form_set_error('agenda_calendars', t('Field can not be left blank'));
  }
  foreach ($ids as $id) {
    if (!valid_email_address($id)) {
      form_set_error('agenda_calendars', t('Invalid calendar ID'));
    }
  }
  
  // old (strtotime parseable)
  $old = $form_state['values']['agenda_old'];
  if (false === strtotime($old)) {
    form_set_error('onthisdate_old', t('Unable to parse input with strtotime'));
  }
  
  // datelimit (positive integer)
  $datelimit = $form_state['values']['agenda_datelimit'];
  if (!is_numeric($datelimit)) {
    form_set_error('agenda_datelimit', t('You must specify a number.'));
  }
  else if ($datelimit <= 0) {
    form_set_error('agenda_datelimit', t('The number must be positive.'));
  }
  
  // cachetime (positive integer)
  $cachetime = $form_state['values']['agenda_cachetime'];
  if (!is_numeric($cachetime)) {
    form_set_error('agenda_cachetime', t('You must specify the number of seconds to cache calendar data.'));
  }
  else if ($cachetime <= 0) {
    form_set_error('agenda_cachetime', t('The cache time must be positive.'));
  }
}


/**
 * Generate the themed agenda block
 *
 * @return string
 */
function agenda_display_block() {    
  // Define all of our calendar sources
  $calendars = variable_get('agenda_calendars', '');
  $calendars = preg_split('@\r\n?|\n@', $calendars);
  if (empty($calendars)) {
    return;
  }

  // Fetch the calendar data
  $events = _agenda_fetch_events($calendars);

  // Group the events by date
  $groupedevents = array();
  foreach ($events as $event) {
    $groupedevents[$event['when']][] = $event;
  }
  ksort($groupedevents);
      
  // Filter the events based on their date
  $old = strtotime(variable_get('agenda_old', 'yesterday'));
  $datelimit = variable_get('agenda_datelimit', 4);
  $count = 0;
  $events = array();
  foreach ($groupedevents as $date => $eventdata) {        
    if ($date <= $old) { continue; }
    if ($count >= $datelimit) { break; }
    $events[$date] = $eventdata;
    $count++;
  }
  
  // Render
  if (count($events)) {
    return theme('agenda_block', $events);
  }
}


/**
 * Provide a page to debug a calendar ID that is not working
 */
function agenda_debug() {
  // Build page
  $form_output = drupal_get_form('agenda_debug_form');
  $output      = array();
 
  // Check form submission
  if (isset($GLOBALS['agenda'])) {
    $output = $GLOBALS['agenda'];
  }

  return theme('agenda_debug', $form_output, $output);
}


/**
 * Create the debugging form
 */
function agenda_debug_form($form_state) {
  $examplecalendar = 'pv8lpo3kgj3347a52gg2shmljo@group.calendar.google.com';
  
  $form['agenda_debug_calendarid'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Calendar ID'),
    '#description'   => t("Enter the Calendar ID you wish to debug. It should look like an email address, usually in the form of <em>{$examplecalendar}</em>"),
    '#required'      => TRUE,
    '#default_value' => variable_get('agenda_debug_calendarid', $examplecalendar),
  );
  
  $form['agenda_debug_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Debug'),
  );
    
  return $form;
}


/**
 * Validation for agenda_debug_form
 */
function agenda_debug_form_validate($form, &$form_state) {
  if (!valid_email_address($form_state['values']['agenda_debug_calendarid'])) {
    form_set_error('agenda_debug_calendarid', t('Invalid calendar ID'));
  }
}


/**
 * Action for agenda_debug_form
 */
function agenda_debug_form_submit($form, &$form_state) {
  variable_set('agenda_debug_calendarid', $form_state['values']['agenda_debug_calendarid']);
  $form_state['rebuild'] = true;
  $googleid = $form_state['values']['agenda_debug_calendarid'];
  
  // Use a poor mans GOTO
  while (true) {
    $output = array();
        
    // Load the calendar
    $sourcepattern = 'http://www.google.com/calendar/feeds/%s/public/basic';
    $source = sprintf($sourcepattern, urlencode(check_plain($googleid)));
    $output[] = 'Fetching feed from ' . $source;
    
    // Load the XML
    $calendar = simplexml_load_file($source);
    if (!$calendar) {
      $output[] = 'Error: Failed to load XML';
      break;
    }
    $output[] = 'Loaded XML successfully';
    
    // Find the events
    $number_of_events = count($calendar->entry);
    $output[] = sprintf('Found %d events', $number_of_events);
    if ($number_of_events === 0) {
      $output[] = 'Warning: Nothing to do with empty calendar, stopping!';
      break;
    }
    
    // Parse the events
    $i = 0;
    $eventdata = array();
    foreach ($calendar->entry as $event) {
      $output[] = sprintf('Loading event %d which is %d bytes', ++$i, strlen($event->asXml()));
      $output[] = sprintf("<pre>%s</pre>", print_r((array) $event, true));
      
      $thisevent = _agenda_parse_event($event);
      if (!$thisevent) {
        $output[] = 'Warning: Failed to parse event!';
        continue;
      }

      $output[] = 'Successfully parsed event:';
      $output[] = '<pre>' . print_r($thisevent, true) . '</pre>';     
      $eventdata[] = $thisevent;
    }
    
    $output[] = sprintf('Parsed %d/%d events successfully', count($eventdata), $number_of_events);
    
    $output[] = sprintf('Begin filtering based on date: string provided (%s) which has timestamp (%d) which has date (%s).',
      $what_is_old = variable_get('agenda_old', ''),
      $what_is_old_ts = strtotime($what_is_old),
      format_date($what_is_old_ts)
      );
    
    foreach ($eventdata as $key => $event) {
      if ($event['when'] < $what_is_old_ts) {
        $output[] = sprintf('&raquo; Discarding <em>%s</em> because <em>%s</em> is older than <em>%s</em>',
          $event['title'],
          format_date($event['when'], 'small'),
          format_date($what_is_old_ts, 'small')
          );
        unset($eventdata[$key]);
      }
    }
    
    $output[] = sprintf('Finished. Started with %d events, will display %d events', $number_of_events, count($eventdata));
    foreach ($eventdata as $event) {
      $output[] = sprintf('&raquo; <em>%s</em> at <em>%s</em>', $event['title'], format_date($event['when']));
    }
    break;
  }
  
  $GLOBALS['agenda'] = $output;
}


/**
 * Given a list of calendar IDs, parse out and return any event data
 *
 * @param array $calendars The calendar IDs
 * @param bool $cacheaction Whether to interact with the cache
 * @access private
 */
function _agenda_fetch_events($calendars, $cacheaction = true) {
  // Check the cache
  if ($cacheaction) {
    $eventdata = cache_get('agenda_eventdata', 'cache');
    if (is_object($eventdata)) {
      return $eventdata->data;
    }
  }

  // Otherwise parse the calendars
  $sourcepattern = 'http://www.google.com/calendar/feeds/%s/public/basic';
  $eventdata = array();
  foreach ($calendars as $calindex => $googleid) {
    $source = sprintf($sourcepattern, urlencode(check_plain($googleid)));
    $calendar = @simplexml_load_file($source);
    
    // If we fail to load the XML, handle it
    if (!$calendar) {
      watchdog('agenda', 'Unable to load the calendar feed (@feed)', array('@feed' => $googleid));
      continue;
    }
    
    // Parse out the event details
    foreach ($calendar->entry as $event) {
      $thisevent = _agenda_parse_event($event);
      if (!$thisevent) {
        continue;
      }

      $thisevent['index']    = (int) $calindex;
      $thisevent['calendar'] = (string) $calendar->title;
      $eventdata[] = $thisevent;
    }
  }
  
  // Cache our data
  if ($cacheaction) {
    $expires = time() + variable_get('agenda_cachetime', 3600);
    cache_set('agenda_eventdata', $eventdata, 'cache', $expires);
  }
  
  return $eventdata;
}


/**
 *
 */
function _agenda_parse_event($event) {
  $thisevent = array();
  
  $content = explode('<br />', $event->content);
  foreach ($content as $item) {
    $item = trim($item);
    if (empty($item) || !strpos($item, ':')) { continue; }
    list ($key, $value) = explode(':', $item, 2);
    $thisevent[strtolower(trim(check_plain($key)))] = filter_xss(trim($value));
  }

  // Make sure we have a when
  // This means no support for recurring events
  if (!isset($thisevent['when'])) {
    return false;
  }
  
  // Parse the date
  $date = '[a-z]+ [0-9]{1,2} [a-z]+ [0-9]{4}';
  $time = '[0-9]{2}:[0-9]{2}';
  $exp = "/^(?<sd>$date)(?: (?<st>$time) to (?<ed>$date) (?<et>$time))?/i";
  $result = preg_match($exp, $thisevent['when'], $matches);

  $thisevent['when'] = strtotime($matches['sd']);
  $thisevent['title'] = (string) $event->title;

  return $thisevent;
}